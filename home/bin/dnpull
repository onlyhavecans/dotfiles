#!/usr/bin/env bash

errors=()

for dir in $(fd --hidden --no-ignore --fixed-strings .git --type d --exclude .direnv --exclude gocode --exclude .github); do
  LOCAL_DIR=$(realpath "$dir/..")
  GIT_LOCAL="git -C $LOCAL_DIR"

  status_message "Updating $LOCAL_DIR"

  if (( $($GIT_LOCAL remote | wc -l) == 0 )); then
    errors+=("! $LOCAL_DIR does not have a remote so skipping.")
    continue
  fi

  if ! $GIT_LOCAL fetch --prune --prune-tags --quiet --force &>/dev/null; then
    errors+=("! $LOCAL_DIR Unable to fetch remote.")
    continue
  fi

  # Deal with different default branch names
  DEFAULT_BRANCH=main
  if $GIT_LOCAL show-ref --verify --quiet "refs/heads/master"; then
    ## If master is renamed upstream rename us here
    if $GIT_LOCAL show-ref --verify --quiet "refs/remotes/origin/main"; then
      $GIT_LOCAL branch -m master main
      $GIT_LOCAL fetch origin
      $GIT_LOCAL branch -u origin/main main
    else
      DEFAULT_BRANCH=master
    fi
  fi

  $GIT_LOCAL diff-index --quiet HEAD -- || $GIT_LOCAL stash

  if ! $GIT_LOCAL checkout $DEFAULT_BRANCH &>/dev/null; then
    errors+=("! $LOCAL_DIR Could not check out $DEFAULT_BRANCH.")
    continue
  fi

  if ! $GIT_LOCAL pull; then
    errors+=("! $LOCAL_DIR Could not pull $DEFAULT_BRANCH.")
  fi

  ## Do some repo cleanup since we got this far
  # looking for
  # error: refs/remotes/origin/HEAD: invalid sha1 pointer 0000000000000000000000000000000000000000
  if ! $GIT_LOCAL fsck --full --no-progress; then
    $GIT_LOCAL remote set-head origin --auto
  fi
  $GIT_LOCAL gc --aggressive --prune=now
done

echo ""
echo ""
status_message "The following repos had errors, please check"
for i in "${errors[@]}"; do
  echo "$i"
done
